
'''
Plan:
    let's first read in the file and store the lazors, etc that shit
        - grid of m*3, n*3 for the board
        - Block object with a subclass
        - let's code the lazor
'''
import re
import itertools as iter


class Block:

    def __init__(self, blockType, fixed):
        self.blockType = blockType
        self.fixed = fixed

    def __call__(self, blockType, status):
        return self.blockType


def playLazor(filename):
    points = []
    parsing = False
    numlazors = 0
    grid = []
    listed = []
    reflect = [0]
    refract = [0]
    opaque = [0]
    lazors = []
    file = open(filename, 'r')
    for lines in file:
        if lines[0] == 'A':
            # moveable, used to solve
            reflect = [int(i) for i in lines.split() if i.isdigit()]
        if lines[0] == 'B':
            # moveable, used to solve
            opaque = [int(i) for i in lines.split() if i.isdigit()]
        if lines[0] == 'P':
            # for the intersection points
            values = [int(i) for i in lines.split() if i.isdigit()]
            points.append(values)
        if lines[0] == 'L':
            # for the lazor sources
            values = [int(i) for i in re.findall(r'-?\d+', lines)]
            lazors.append(values)
            numlazors += 1
        if lines[0] == 'C':
            # moveable, used to solve
            refract = [int(i) for i in lines.split() if i.isdigit()]
        if lines.startswith('GRID START'):
            parsing = True
        if lines.startswith('GRID STOP'):
            parsing = False
        if parsing is True:
            if not lines.startswith('GRID'):
                A = lines.replace(" ", "")
                B = A.replace("\n", "")
                listed = []
                for i in range(len(B)):
                    listed.append(B[i])
                grid.append(listed)
   # originalBoard = createGrid(grid, points, lazors)
    board = createGrid(grid, points, lazors)
    file.close()
    solver(board, grid, lazors, numlazors, points, reflect, opaque, refract)


def createGrid(grid, points, lazors):
    board = [
        [0 for i in range(len(grid[0])*2 + 1)]
        for j in range(len(grid)*2 + 1)]

    for a in range(len(grid)):
        for b in range(len(grid[0])):
            if grid[a][b] != 'o':
                board[2*a+1][2*b+1] = Block(grid[a][b], True)
            else:
                board[2*a+1][2*b+1] = 2
    # for a in range(len(points)):
        # board[points[a][0]][points[a][1]] = 'L'
    # for b in range(len(lazors)):
        # board[lazors[b][0]][lazors[b][1]] = 'L'
    return board


def onBoard(x, y, board):
    return x >= 0 and x < len(board[0]) and y >= 0 and y < len(board)


def pathLazor(board, grid, lazor, numlazors):
    newLazor = [0 for i in range(len([lazor]))]
    for n in range(len([lazor])):
        newLazor[n] = lazor[n]

    VALIDLAZOR = True
    VALIDOPAQUE = False
    directions = [
        (0, 1),
        (0, -1),
        (-1, 0),
        (1, 0)
    ]

    while len(newLazor) > 0:
        cell = newLazor[0]
        removed = False
        if onBoard(cell[0], cell[1], board):
            if board[cell[1]][cell[0]] == 0:
                board[cell[1]][cell[0]] = 1
            for a in range(len(directions)):
                neighborx = cell[1]+directions[a][0]
                neighbory = cell[0]+directions[a][1]
                if onBoard(neighborx, neighbory, board) and isinstance(board[neighbory][neighborx], Block):
                    if board[neighbory][neighborx].blockType == 'A':
                        if neighborx == cell[0] + cell[2]:
                            newLazor[0][2] *= -1
                            newLazor[0][3] *= -1
                        elif neighbory == cell[1] + cell[3]:
                            newLazor[0][3] *= -1
                    elif board[neighbory][neighborx].blockType == 'B':
                        if neighborx == cell[0] + cell[2] or neighbory == cell[1] + cell[3]:
                            newLazor.remove(newLazor[0])
                            removed = True
                    elif board[neighbory][neighborx].blockType == 'C':
                        newLazor.append(newLazor[0])
                        if neighborx == cell[0] + cell[2]:
                            newLazor[0][2] *= -1
                            newLazor[0][3] *= -1
                        elif neighbory == cell[1] + cell[3]:
                            newLazor[0][3] *= -1
            if not removed:
                newLazor[0] = [cell[0] + newLazor[0][2], cell[1] +
                               newLazor[0][3], newLazor[0][2], newLazor[0][3]]
        else:
            newLazor.remove(newLazor[0])
    return board
# where the board is populated with '1' for lazors


def solver(board, grid, lazors, numlazors, points, reflect, opaque, refract):

    def blockPlacement(board, reflect, opaque, refract, combinations):
        while len(combinations) != 0:
            noReflect = True
            noRefract = True
            noOpaque = True
            if reflect != 0:
                noReflect = False
            if opaque != 0:
                noOpaque = False
            if refract != 0:
                noRefract = False
            if not noReflect:
                board[combinations[0][0]][combinations[0][1]
                                          ] = Block('A', 'moveable')
                reflect -= 1
                combinations.remove(combinations[0])
            if not noOpaque:
                board[combinations[0][0]][combinations[0][1]
                                          ] = Block('B', 'moveable')
                opaque -= 1
                combinations.remove(combinations[0])
            if not noRefract:
                board[combinations[0][0]][combinations[0][1]
                                          ] = Block('C', 'moveable')
                refract -= 1
                combinations.remove(combinations[0])

        return board

    def validMove(board):
        validMoves = []
        for y in range(len(board)):
            for x in range(len(board[0])):
                if board[y][x] == 2:
                    validMoves.append((y, x))
        return validMoves

    def checkLazors(board, points):
        numValidTarget = 0
        for a in range(len(points)):
            if board[points[a][1]][points[a][0]] == 1:
                numValidTarget += 1
        if len(points) == numValidTarget:
            return True
        else:
            return False

    validMoves = validMove(board)
    WIN = False
    totalMovableBlocks = reflect[0] + refract[0] + opaque[0]
    combinations = list(iter.combinations(validMoves, totalMovableBlocks))
    while len(combinations) > 0:
        newBoard = blockPlacement(
            board, reflect[0], opaque[0], refract[0], list(combinations[0]))
        lazorBoard = pathLazor(newBoard, grid, lazors, numlazors)
        WIN = checkLazors(lazorBoard, points)
        if WIN:
            print('WINNNNNNN')
            break
        combinations.remove(combinations[0])
        board = createGrid(grid, points, lazors)

    if WIN is False:
        print('You suck')


if __name__ == '__main__':
    playLazor('dark_1.bff')
