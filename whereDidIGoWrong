
'''
Plan:
    let's first read in the file and store the lazors, etc that shit
        - grid of m*3, n*3 for the board
        - Block object with a subclass
        - let's code the lazor
'''
import re
import itertools as iter


class Block:

    def __init__(self, blockType):
        self.blockType = blockType

    def __call__(self, blockType):
        return self.blockType


def playLazor(filename):
    points = []
    parsing = False
    numlazors = 0
    grid = []
    listed = []
    reflect = [0]
    refract = [0]
    opaque = [0]
    lazors = []
    OGLazors = []
    file = open(filename, 'r')
    for lines in file:
        if lines[0] == 'A':
            # moveable, used to solve
            reflect = [int(i) for i in lines.split() if i.isdigit()]
        if lines[0] == 'B':
            # moveable, used to solve
            opaque = [int(i) for i in lines.split() if i.isdigit()]
        if lines[0] == 'P':
            # for the intersection points
            values = [int(i) for i in lines.split() if i.isdigit()]
            points.append(values)
        if lines[0] == 'L':
            # for the lazor sources
            values = [int(i) for i in re.findall(r'-?\d+', lines)]
            lazors.append(tuple(values))
            OGLazors.append(values)
            numlazors += 1
        if lines[0] == 'C':
            # moveable, used to solve
            refract = [int(i) for i in lines.split() if i.isdigit()]
        if lines.startswith('GRID START'):
            parsing = True
        if lines.startswith('GRID STOP'):
            parsing = False
        if parsing is True:
            if not lines.startswith('GRID'):
                A = lines.replace(" ", "")
                B = A.replace("\n", "")
                listed = []
                for i in range(len(B)):
                    listed.append(B[i])
                grid.append(listed)
   # originalBoard = createGrid(grid, points, lazors)
    board = createGrid(grid, points)
    file.close()
    solver(board, grid, lazors, numlazors, points,
           reflect, opaque, refract, OGLazors)


def createGrid(grid, points):
    board = [
        [0 for i in range(len(grid[0])*2 + 1)]
        for j in range(len(grid)*2 + 1)]

    for a in range(len(grid)):
        for b in range(len(grid[0])):
            if grid[a][b] != 'o':
                board[2*a+1][2*b+1] = Block(grid[a][b])
            else:
                board[2*a+1][2*b+1] = 2
    # for a in range(len(points)):
        # board[points[a][0]][points[a][1]] = 'L'
    # for b in range(len(lazors)):
        # board[lazors[b][0]][lazors[b][1]] = 'L'
    return board


def onBoard(x, y, board):
    return x >= 0 and x < len(board[0]) and y >= 0 and y < len(board)


def pathLazor(board, grid, lazor, numlazors):
    newLazor = [0 for i in range(numlazors)]
    for n in range(numlazors):
        newLazor[n] = list(lazor[n])

    VALIDLAZOR = True
    VALIDOPAQUE = False
    directions = [
        (0, 1),
        (0, -1),
        (-1, 0),
        (1, 0)
    ]

    while len(newLazor) > 0:
        cell = newLazor[0]
        cellx = cell[0]
        celly = cell[1]
        removed = False
        if onBoard(cellx, celly, board):
            if board[celly][cellx] == 0:
                board[celly][cellx] = 1
            for a in range(len(directions)):
                neighborx = cellx + directions[a][0]
                neighbory = celly + directions[a][1]
                if onBoard(neighborx, neighbory, board) and isinstance(board[neighbory][neighborx], Block):
                    if board[neighbory][neighborx].blockType == 'A':
                        if neighborx == cellx + cell[2]:
                            newLazor[0][2] *= -1
                        elif neighbory == celly + cell[3]:
                            newLazor[0][3] *= -1
                    elif board[neighbory][neighborx].blockType == 'B':
                        if neighborx == cellx + cell[2] or neighbory == celly + cell[3]:
                            newLazor.remove(newLazor[0])
                            removed = True
                    elif board[neighbory][neighborx].blockType == 'C':
                        if neighborx == cellx + cell[2]:
                            newLazor.append([cellx + newLazor[0][2], celly +
                                             newLazor[0][3], newLazor[0][2], newLazor[0][3]])
                            newLazor[0][2] *= -1
                        elif neighbory == celly + cell[3]:
                            newLazor.append([cellx + newLazor[0][2], celly +
                                             newLazor[0][3], newLazor[0][2], newLazor[0][3]])
                            newLazor[0][3] *= -1
            if not removed:
                newLazor[0] = [cellx + newLazor[0][2], celly +
                               newLazor[0][3], newLazor[0][2], newLazor[0][3]]
        else:
            newLazor.remove(newLazor[0])

    return board
# where the board is populated with '1' for lazors


def solver(board, grid, lazors, numlazors, points, reflect, opaque, refract, OGLazors):

    def blockPlacement(board, reflect, opaque, refract, combinations):
        while len(combinations) > 0:
            noReflect = True
            noRefract = True
            noOpaque = True
            if reflect != 0:
                noReflect = False
            if opaque != 0:
                noOpaque = False
            if refract != 0:
                noRefract = False
            if not noReflect:
                board[combinations[0][1]][combinations[0][0]
                                          ] = Block('A')
                reflect -= 1
                combinations.remove(combinations[0])
            if not noOpaque:
                board[combinations[0][1]][combinations[0][0]
                                          ] = Block('B')
                opaque -= 1
                combinations.remove(combinations[0])
            if not noRefract:
                board[combinations[0][1]][combinations[0][0]
                                          ] = Block('C')
                refract -= 1
                combinations.remove(combinations[0])

        return board

    def validMove(board):
        validMoves = []
        for y in range(len(board)):
            for x in range(len(board[0])):
                if board[y][x] == 2:
                    validMoves.append((x, y))
        return validMoves

    def checkLazors(board, points):
        numValidTarget = 0
        for a in range(len(points)):
            if board[points[a][1]][points[a][0]] == 1:
                numValidTarget += 1
        if len(points) == numValidTarget:
            return True
        else:
            return False

    validMoves = validMove(board)
    WIN = False
    totalMovableBlocks = reflect[0] + refract[0] + opaque[0]
    permutations = list(iter.permutations(validMoves, totalMovableBlocks))
    # board index is board[y][x]
    while len(permutations) > 0:
        if permutations[0] == ((1, 5), (5, 1), (7, 3)):
            WIN = True
        newBoard = blockPlacement(
            board, reflect[0], opaque[0], refract[0], list(permutations[0]))
        lazorBoard = pathLazor(board, grid, lazors, numlazors)
        WIN = checkLazors(lazorBoard, points)
        if WIN is True:
            print('WINNNNNNN')
            break
        permutations.remove(permutations[0])
        board = createGrid(grid, points)
    if WIN is True:
        print("WHY ARE YOU LIKE THIS")
    if WIN is False:
        print('You suck')


if __name__ == '__main__':
    playLazor('mad_1.bff')
