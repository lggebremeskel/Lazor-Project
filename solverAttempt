def blockPlacement(board, blockPerm, combo, lazors, numlazors, points):
    WIN = False
    index = 0
    while len(blockPerm) > index:
        for i in range(len(blockPerm[0])):
            board[combo[i][1]][combo[i][0]] = Block(blockPerm[index][i])
        lazorBoard = pathLazor(board, lazors, numlazors)
        WIN = checkLazors(lazorBoard, points)
        if not WIN:
            index += 1
        else:
            break
    return [WIN, lazorBoard]


def validMove(board):
    validMoves = []
    for y in range(len(board)):
        for x in range(len(board[0])):
            if board[y][x] == 2:
                validMoves.append((x, y))
    return validMoves


def checkLazors(board, points):
    numValidTarget = 0
    for a in range(len(points)):
        if board[points[a][1]][points[a][0]] == 1:
            numValidTarget += 1
    if len(points) == numValidTarget:
        return True
    else:
        return False


def solver(board, grid, lazors, numlazors, points, blocks):

    validMoves = validMove(board)
    totalMovableBlocks = blocks[0]+blocks[1] + blocks[2]
    coordCombo = list(iter.combinations(validMoves, totalMovableBlocks))
    blockList = []
    if blocks[0] > 0:
        for i in range(blocks[0]):
            blockList.append('A')
    if blocks[1] > 0:
        for i in range(blocks[1]):
            blockList.append('B')
    if blocks[2] > 0:
        for i in range(blocks[2]):
            blockList.append('C')
    blockPerm = list(iter.permutations(blockList))
    # board index is board[y][x]
    blockPerm = list(dict.fromkeys(blockPerm))
    for coord in coordCombo:
        [WIN, outputBoard] = blockPlacement(board, blockPerm, list(
            coord), lazors, numlazors, points)
        if WIN is True:
            print('WINNNNNNN')
            winningBoard = outputBoard
        board = createGrid(grid, points)
    print(winningBoard)
